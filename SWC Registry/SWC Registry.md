SWC Registry - Smart Contract Weakness Classification
======================================================

The following table contains an overview of the SWC Cases taken in consideration while developing the smart contracts. 

| SWC ID      | Title       | Description   | Inference |
| :---        |    :----:   |          :---: |      :---: |
| [SWC-100](https://swcregistry.io/docs/SWC-100)    | **Function Default Visibility**      | Functions that do not have a **_function visibility_** type specified are public by default. This can lead to a vulnerability if a developer forgot to set the visibility and a malicious user is able to make unauthorized or unintended state changes.|It was an issue in `v0.4.X` solidity versions but after `v0.5.X` solidity makes it compulsory to define visibility. (Currently using solidity `v0.8.2`) |
| [SWC-101](https://swcregistry.io/docs/SWC-101)    | **Integer Overflow and Underflow**   | An _**overflow / underflow**_ happens when an arithmetic operation reaches the maximum or minimum size of a type. An integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits â€“ either larger than the maximum or lower than the minimum representable value.|The issue persists in versions before `v0.8.X`. After `v0.8.X`, underflow and overflow of integers are by default handled by solidity. |
| [SWC-102](https://swcregistry.io/docs/SWC-102)    | **Outdated Compiler Version**        | Using an **_outdated compiler version_** can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.|There are only two known vulnerabilities after `v0.8.X`. <br> 1. Use of `keccak`. (Not used in the current contracts) <br> 2. Use of `abi.decode`. (Not used in the current contracts)|
| [SWC-103](https://swcregistry.io/docs/SWC-103)    | **Floating Pragma**                  | Contracts should be deployed with the same **_compiler version_** and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.| Using a fixed compiler version `v0.8.2`.|
| [SWC-104](https://swcregistry.io/docs/SWC-104)    | **Unchecked Call Return Value**      | The _**return value**_ of a _**message call**_ is not **checked**. Execution will resume even if the called contract throws an exception. If the call fails accidentally or an attacker forces the call to fail, this may cause unexpected behaviour in the subsequent program logic. | How to handle : <BR> If you choose to use low-level call methods, make sure to handle the possibility that the call will fail by checking the return value. <br> **Not using low-level call** methods instead **using Abstraction** to call external contracts.|
| [SWC-105](https://swcregistry.io/docs/SWC-105)    | **Unprotected Ether Withdrawal**     | Due to missing or **insufficient access controls**, malicious parties can withdraw some or all Ether from the contract account. <br> This bug is sometimes _**caused by unintentionally exposing initialization functions**_. By wrongly naming a function intended to be a constructor, the constructor code ends up in the runtime byte code and can be called by anyone to re-initialize the contract.| Use of `require` & `assert` statements **or** `modifier functions` needed in case of accessing functions.|
| [SWC-106](https://swcregistry.io/docs/SWC-106)    | **Unprotected SELFDESTRUCT Instruction**     | Due to missing or **insufficient access controls**, malicious parties can **_self-destruct the contract_**. | Remove `self destruct` unless absolutely needed.|
| [SWC-107](https://swcregistry.io/docs/SWC-107)    | **Reentrancy**     | One of the major dangers of calling external contracts is that they can take over the control flow. In the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways. | The best practices to avoid `Reentrancy` weaknesses are: <br> 1. Make sure all **internal state changes** are performed before the call is executed. This is known as the _Checks-Effects-Interactions pattern_. <br> 2. Use a **Reentrancy Lock** (i.e. OpenZeppelin's ReentrancyGuard).|
| [SWC-108](https://swcregistry.io/docs/SWC-108)    | **State Variable Default Visibility**     | Labeling the **visibility** explicitly makes it easier to catch incorrect assumptions about **who can access** the variable. |  Making sure all **variables are marked** with their **state**.|
| [SWC-109](https://swcregistry.io/docs/SWC-109)    | **Uninitialized Storage Pointer**     | Uninitialized **local storage variables** can point to **unexpected storage locations** in the contract, which can lead to intentional or unintentional vulnerabilities. | As of compiler version `v0.5.0` and higher this issue has been **systematically resolved** as contracts with uninitialised storage pointers do no longer compile.|
| [SWC-110](https://swcregistry.io/docs/SWC-110)    | **Assert Violation**     | The Solidity `assert()` function is meant to assert **invariants**. Properly functioning code should never reach a failing assert statement. A reachable assertion can mean one of two things:<br>1. A bug exists in the contract that allows it to enter an invalid state.<br>2. The assert statement is used incorrectly, e.g. to validate inputs.| Using `assert()` to handle invariants or strange situations in the contract.|
| [SWC-111](https://swcregistry.io/docs/SWC-111)    | **Use of Deprecated Solidity Functions**     | Several functions and operators in Solidity are **_deprecated_**. Using them leads to reduced code quality. With new major versions of the Solidity compiler, deprecated functions and operators may result in **side effects** and **compile errors**.| Avoid use of the deprecated functions, use the alternatives.|
| [SWC-112](https://swcregistry.io/docs/SWC-112)    | **Delegatecall to Untrusted Callee**     | `delegatecall` allows a smart contract to dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract. <br> Calling into untrusted contracts is very dangerous, as the code at the target address can change any storage values of the caller and has full control over the caller's balance.| Handling all the scenarios w.r.t to the `delegatecall` being initialized with the smart contracts.|
| [SWC-113](https://swcregistry.io/docs/SWC-113)    | **DoS with Failed Call**     | **External calls can fail accidentally or deliberately**, which can cause a DoS condition in the contract. To minimize the damage caused by such failures, it is better to **isolate** each **external call** into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically (this also reduces the chance of problems with the gas limit). | Implementing the logic in such a way that the external calls if they fail, they fail gracefully, i.e. without having a major impact on the functionality of the contract.|
| [SWC-114](https://swcregistry.io/docs/SWC-114)    | **Transaction Order Dependence**     | Execution of multiple functions using a shared state variable can lead to concurrency issues & with Improper Synchronization, a _Race Condition_.| A possible way to remedy for race conditions in submission of information in exchange for a reward is called a **_commit reveal hash scheme_**.|
| [SWC-115](https://swcregistry.io/docs/SWC-115)    | **Authorization through tx.origin**     | `tx.origin` is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable for authorization could make a contract vulnerable if an authorized account calls into a malicious contract. A call could be made to the vulnerable contract that passes the authorization check since tx.origin returns the original sender of the transaction which in this case is the authorized account.| `tx.origin` should not be used for **_authorization_**. Use `msg.sender` instead.|
| [SWC-116](https://swcregistry.io/docs/SWC-116)    | **Block values as a proxy for time**     | Contracts often need access to time values to perform certain types of functionality. Values such as `block.timestamp`, and `block.number` can give you a sense of the current time or a time delta, however, they are not safe to use for most purposes. | Developers should write smart contracts with the notion that block values are not precise, and the use of them can lead to unexpected effects. A miner can manipulate `block.timestamp` value for upto 15 mins, the contract uses **_DAYs_** logic hence, it's safe to use it.|
| [SWC-117](https://swcregistry.io/docs/SWC-117)    | **Signature Malleability**     | A system that performs **signature verification** on contract level might be susceptible to attacks if the signature is part of the signed message hash. **Valid signatures** could be created by a _malicious user_ to replay previously signed messages.| A **_signature_** should **never be included** into a signed **message hash** to check if previously messages have been processed by the contract.|
| [SWC-118](https://swcregistry.io/docs/SWC-118)    | **Incorrect Constructor Name**     | **Constructors** are special functions that are called only once during the **_contract creation_**. A function meant to become a constructor becomes a normal, callable function if its name doesn't exactly match the contract name. This behavior sometimes leads to **security issues**, in particular when smart contract code is re-used with a different name but the name of the constructor function is not changed accordingly.| Before Solidity version `v0.4.22`, the only way of defining a constructor was to create a function with the same name as the contract class containing it. Fixed after Solidity version `v0.4.22`.|
| [SWC-119](https://swcregistry.io/docs/SWC-119)    | **Shadowing State Variables**     | Solidity allows for **ambiguous** naming of **state variables** when inheritance is used. **Shadowing** state variables can also occur within a single contract when there are multiple definitions on the contract and function level.| Review storage variable layouts for your contract systems carefully and remove any ambiguities. Always check for compiler warnings as they can flag the issue within a single contract. Also, make sure **NOT** to **_override_** any state variables.|
| [SWC-120](https://swcregistry.io/docs/SWC-120)    | **Weak Sources of Randomness from Chain Attributes**     | Ability to **_generate random numbers_** is very helpful in all kinds of applications. Creating a strong enough source of randomness in Ethereum is very **challenging**.| Remediation : <br> Using commitment scheme, e.g. RANDAO. <br> We don't have any need to generate a random number in our contracts.|
| [SWC-123](https://swcregistry.io/docs/SWC-123)    | **Requirement Violation**     | The Solidity `require()` construct is meant to validate external inputs of a function. In most cases, such external inputs are provided by callers, but they may also be returned by callees.| Logical condition should be balanced (Not too strong / weak) to allow all the valid external inputs.Using require to make sure that **_invalid inputs_** do not go through.|
| [SWC-124](https://swcregistry.io/docs/SWC-124)    | **Write to Arbitrary Storage Location**     | A **smart contract's data is persistently stored** at some storage location on the EVM level. The contract is responsible for ensuring that only authorized user or contract accounts may write to sensitive storage locations. If an attacker is able to write to arbitrary storage locations of a contract, the **authorization** checks may easily be **circumvented**. This can allow an attacker to corrupt the storage; for instance, by overwriting a field that stores the address of the contract owner.| Make sure that writes to one data structure **cannot inadvertently overwrite** entries of another data structure.|
| [SWC-125](https://swcregistry.io/docs/SWC-125)    | **Incorrect Inheritance Order**     | Solidity supports **multiple inheritance**, meaning that one contract can inherit several contracts. Multiple inheritance **introduces ambiguity** called **_Diamond Problem_**: if two or more base contracts define the same function, which one should be called in the child contract?| When inheriting multiple contracts, especially if they have identical functions, a developer should carefully _specify inheritance in the correct order_. The **_rule of thumb_** is to inherit contracts from **more general** to **more specific**.|
| [SWC-126](https://swcregistry.io/docs/SWC-126)    | **Insufficient Gas Griefing**     | Insufficient gas griefing attacks can be performed on contracts which accept data and use it in a sub-call on another contract. If the sub-call fails, either the whole transaction is reverted, or execution is continued. In the case of a **relayer contract**, the user who executes the transaction, the 'forwarder', can effectively censor transactions by using just enough gas to execute the transaction, but not enough for the sub-call to succeed.| Can be handled using two approaches: <br> 1. Allow only trusted users to relay transactions. <br> 2. Require the forwarder to provide enough gas.|
| [SWC-127](https://swcregistry.io/docs/SWC-127)    | **Arbitrary Jump with Function Type Variable**     | Solidity **supports function types**. That is, a variable of function type can be assigned with a reference to a function with a matching signature. The function saved to such variable can be called just like a regular function. The problem arises when a user has the ability to arbitrarily change the function type variable and thus execute random code instructions.| The **_use of assembly_** should be **minimal**. A developer should _not allow a user to assign arbitrary values to function_ type variables.|
| [SWC-128](https://swcregistry.io/docs/SWC-128)    | **DoS With Block Gas Limit**     | Programming patterns that are harmless in centralized applications can lead to **_Denial of Service_** conditions in smart contracts when the cost of executing a function **exceeds the block gas limit**. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition.| **Don't loop** over an **array of unknown size**, either _limit the size_ or _potentially take multiple blocks_ to complete.|
| [SWC-129](https://swcregistry.io/docs/SWC-129)    | **Typographical Error**     | A typographical error can occur for example when the intent of a defined operation is to sum a number to a variable (+=) but it has accidentally been defined in a wrong way (=+), **introducing a typo** which happens to be a valid operator. Instead of calculating the sum it initializes the variable again.| Using intended operators and validating the scope of the operation to ensure the state of the functions is changed/modified as expected.|
| [SWC-130](https://swcregistry.io/docs/SWC-130)    | **Right-To-Left-Override control character (U+202E)**     | Malicious actors can use the **Right-To-Left-Override** unicode character to **_force RTL text rendering and confuse users_** as to the real intent of a contract.| Very few legitimate uses of the U+202E character. It should not appear in the source code of a smart contract.|
| [SWC-131](https://swcregistry.io/docs/SWC-131)    | **Presence of unused variables**     | **Unused variables** are allowed in Solidity and they _do not pose a direct security issue_. It is best practice though to avoid them as they can. | Remove all unused variables from the code base.|
| [SWC-132](https://swcregistry.io/docs/SWC-132)    | **Unexpected Ether balance**     | Contracts can behave erroneously when they strictly assume a specific Ether balance. It is always possible to forcibly send ether to a contract (without triggering its fallback function), using `selfdestruct`, or by mining to the account. In the worst case scenario this could **lead to DOS** conditions that might render the contract unusable.| **Avoid strict** equality **checks** for the Ether balance in a contract.|
| [SWC-133](https://swcregistry.io/docs/SWC-132)    | **Hash Collisions With Multiple Variable Length Arguments**     | Using `abi.encodePacked()` with multiple variable length arguments can, in certain situations, **_lead to a hash collision_**. Since `abi.encodePacked()` packs all elements in order regardless of whether they're part of an array, you can move elements between arrays and, so long as all elements are in the same order, it will return the same encoding. In a **signature verification** situation, an **attacker** could **exploit this** by modifying the position of elements in a previous function call to effectively **bypass authorization**.| When using `abi.encodePacked()`, it's crucial to ensure that a **matching signature cannot be achieved** using different parameters. To do so, either **do not allow users access** to parameters used in `abi.encodePacked()`, or use fixed length arrays.|
| [SWC-134](https://swcregistry.io/docs/SWC-134)    | **Message call with hardcoded gas amount**     | The `transfer()` and `send()` functions forward a **_fixed amount of 2300 gas_**. Historically, it has often been recommended to use these functions for value transfers to **_guard against reentrancy_** attacks.However, the **gas cost** of EVM instructions **may change** significantly **during hard forks** which **may break already deployed contract** systems that make fixed assumptions about gas costs.| Developer should **avoid** using low-level calls & **NOT** hardcode the _gas amount_.|
| [SWC-135](https://swcregistry.io/docs/SWC-135)    | **Code With No Effects**     | In Solidity, it's possible to write code that does not produce the intended effects. Currently, the solidity compiler will **not return a warning for effect-free code**. This can lead to the **_introduction of "dead" code_** that does not properly performing an intended action.| Ensure that your contract **works as intended**. Write **unit tests** to **_verify correct behaviour of the code_**.|
| [SWC-136](https://swcregistry.io/docs/SWC-136)    | **Unencrypted Private Data On-Chain**     | It is a common **_misconception that private type variables cannot be read_**. Even if your contract is not published, attackers can look at contract transactions to **determine values stored** in the state of the contract.| Hence, any private data should either be **_stored off-chain_**, or carefully **_encrypted_**. No-sensitive data is stored in current contract.|